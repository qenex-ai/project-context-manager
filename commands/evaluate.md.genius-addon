# Genius Recommendations Addon for /evaluate Command

## Add this section after Step 8 in evaluate.md

##### Step 9: Genius-Level Recommendations

```bash
echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
echo "  ğŸ’¡ Genius Recommendations"
echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
echo ""

# Pattern Recognition & Architecture Insights
echo "ğŸ—ï¸  Architecture Patterns:"
echo ""

# Detect anti-patterns
if grep -rq "god.*class\|manager.*class" --include="*.py" "$PROJECT_ROOT"; then
  echo "  âš ï¸  Detected God Object pattern"
  echo "      â†’ Refactor using: Single Responsibility Principle"
  echo "      â†’ Split into: [Domain]Service, [Domain]Repository, [Domain]Validator"
  echo "      â†’ Example: UserManager â†’ UserService + UserRepository + UserValidator"
  echo ""
fi

# Detect coupling issues
IMPORT_COUNT=$(grep -r "^from \|^import " --include="*.py" "$PROJECT_ROOT" | wc -l)
FILE_COUNT=$(find "$PROJECT_ROOT" -name "*.py" | wc -l)
if [ "$FILE_COUNT" -gt 0 ]; then
  IMPORTS_PER_FILE=$((IMPORT_COUNT / FILE_COUNT))
  if [ "$IMPORTS_PER_FILE" -gt 10 ]; then
    echo "  âš ï¸  High coupling detected (avg $IMPORTS_PER_FILE imports/file)"
    echo "      â†’ Apply: Dependency Inversion Principle"
    echo "      â†’ Pattern: Introduce interfaces/abstractions"
    echo "      â†’ Tool: Create dependency injection container"
    echo ""
  fi
fi

# Suggest architectural improvements
echo "  âœ¨ Suggested patterns for this phase:"
if echo "$CHUNK_NAME" | grep -iq "api\|endpoint"; then
  echo "      â†’ Controller-Service-Repository pattern"
  echo "      â†’ Middleware pipeline for cross-cutting concerns"
  echo "      â†’ DTOs for request/response validation"
elif echo "$CHUNK_NAME" | grep -iq "database\|model"; then
  echo "      â†’ Repository pattern for data access"
  echo "      â†’ Unit of Work pattern for transactions"
  echo "      â†’ Query objects for complex queries"
elif echo "$CHUNK_NAME" | grep -iq "auth"; then
  echo "      â†’ Strategy pattern for auth providers (JWT, OAuth, API key)"
  echo "      â†’ Decorator pattern for permission checks"
  echo "      â†’ Chain of Responsibility for middleware"
fi
echo ""

# Performance Optimization Insights
echo "ğŸš€ Performance Optimizations:"
echo ""

# Check for N+1 queries
if grep -rq "for.*in.*:" --include="*.py" "$PROJECT_ROOT"; then
  if grep -rq "\.get\|\.filter\|SELECT" --include="*.py" "$PROJECT_ROOT"; then
    echo "  âš ï¸  Potential N+1 query pattern detected"
    echo "      â†’ Solution: Use select_related() / prefetch_related() (Django)"
    echo "      â†’ Solution: Use JOIN queries instead of nested loops"
    echo "      â†’ Tool: Enable SQL query logging to verify"
    echo "      â†’ Benchmark: Profile with py-spy or cProfile"
    echo ""
  fi
fi

# Check for missing indexes
if grep -rq "WHERE\|ORDER BY" --include="*.sql" --include="*.py" "$PROJECT_ROOT"; then
  echo "  ğŸ’¡ Database query optimization opportunities:"
  echo "      â†’ Add indexes on frequently queried columns"
  echo "      â†’ Use composite indexes for multi-column filters"
  echo "      â†’ Command: python manage.py sqlmigrate <app> <migration>"
  echo "      â†’ Monitor: Enable query logging, check EXPLAIN ANALYZE"
  echo ""
fi

# Check for caching opportunities
if ! grep -rq "cache\|Cache\|memoize" --include="*.py" "$PROJECT_ROOT"; then
  echo "  ğŸ’¡ Caching strategy needed:"
  echo "      â†’ Level 1: Function-level memoization (@lru_cache)"
  echo "      â†’ Level 2: Application caching (Redis, Memcached)"
  echo "      â†’ Level 3: HTTP caching (ETag, Cache-Control headers)"
  echo "      â†’ Tool: django-cacheops, Flask-Caching, or functools.lru_cache"
  echo ""
fi

# Async opportunities
if grep -rq "requests\.\|urllib" --include="*.py" "$PROJECT_ROOT"; then
  if ! grep -rq "async\|await\|asyncio" --include="*.py" "$PROJECT_ROOT"; then
    echo "  ğŸ’¡ Async/await opportunity for I/O-bound operations:"
    echo "      â†’ Migrate: requests â†’ httpx (async HTTP)"
    echo "      â†’ Pattern: Use asyncio.gather() for parallel requests"
    echo "      â†’ Expected: 5-10x improvement for I/O-bound tasks"
    echo "      â†’ Example: async def fetch_data() / await fetch_data()"
    echo ""
  fi
fi

# Security Best Practices
echo "ğŸ”’ Security Enhancements:"
echo ""

# Check for security headers
if grep -rq "Flask\|fastapi\|@app.route" --include="*.py" "$PROJECT_ROOT"; then
  if ! grep -rq "X-Frame-Options\|Content-Security-Policy\|Strict-Transport-Security" --include="*.py" "$PROJECT_ROOT"; then
    echo "  âš ï¸  Missing security headers"
    echo "      â†’ Add: X-Frame-Options: DENY"
    echo "      â†’ Add: Content-Security-Policy: default-src 'self'"
    echo "      â†’ Add: Strict-Transport-Security: max-age=31536000"
    echo "      â†’ Tool: Flask-Talisman, secure.py middleware"
    echo ""
  fi
fi

# Check for input validation
if grep -rq "request\.args\|request\.form\|request\.json" --include="*.py" "$PROJECT_ROOT"; then
  if ! grep -rq "marshmallow\|pydantic\|validator" --include="*.py" "$PROJECT_ROOT"; then
    echo "  âš ï¸  Input validation needed"
    echo "      â†’ Library: Pydantic (type-safe validation)"
    echo "      â†’ Library: Marshmallow (schema validation)"
    echo "      â†’ Pattern: Validate early, fail fast"
    echo "      â†’ Example: @app.post('/api', response_model=ResponseSchema)"
    echo ""
  fi
fi

# Check for rate limiting
if grep -rq "@app.route\|@api" --include="*.py" "$PROJECT_ROOT"; then
  if ! grep -rq "limiter\|RateLimiter\|rate_limit" --include="*.py" "$PROJECT_ROOT"; then
    echo "  ğŸ’¡ Add rate limiting for API protection:"
    echo "      â†’ Library: Flask-Limiter, slowapi (FastAPI)"
    echo "      â†’ Strategy: 100 requests/hour per user, 1000/hour per IP"
    echo "      â†’ Storage: Redis for distributed rate limiting"
    echo "      â†’ Fallback: In-memory for development"
    echo ""
  fi
fi

# Testing Strategies
echo "ğŸ§ª Testing Improvements:"
echo ""

# Property-based testing
if [ "$TEST_COUNT" -gt 0 ]; then
  if ! grep -rq "hypothesis\|@given" --include="*.py" "$PROJECT_ROOT"; then
    echo "  ğŸ’¡ Upgrade to property-based testing:"
    echo "      â†’ Library: Hypothesis (Python), proptest (Rust)"
    echo "      â†’ Benefit: Discovers edge cases traditional tests miss"
    echo "      â†’ Example: @given(st.integers()) def test_absolute(n)"
    echo "      â†’ Use case: Data validation, parsing, math operations"
    echo ""
  fi
fi

# Mutation testing
if ! grep -rq "mutmut\|mutpy" --include="*.py" "$PROJECT_ROOT"; then
  echo "  ğŸ’¡ Verify test quality with mutation testing:"
  echo "      â†’ Tool: mutmut (Python), cargo-mutants (Rust)"
  echo "      â†’ Purpose: Ensure tests actually catch bugs"
  echo "      â†’ Command: mutmut run"
  echo "      â†’ Target: >80% mutation kill rate"
  echo ""
fi

# Contract testing for APIs
if grep -rq "@app.route\|@api" --include="*.py" "$PROJECT_ROOT"; then
  echo "  ğŸ’¡ Add API contract testing:"
  echo "      â†’ Tool: Pact (consumer-driven contracts)"
  echo "      â†’ Tool: Dredd (API blueprint testing)"
  echo "      â†’ Pattern: Generate OpenAPI spec, validate against it"
  echo "      â†’ Benefit: Catch breaking changes before deployment"
  echo ""
fi

# Refactoring Suggestions
echo "â™»ï¸  Refactoring Opportunities:"
echo ""

# Long functions
LONG_FUNCS=$(grep -rn "^def \|^fn " --include="*.py" --include="*.rs" "$PROJECT_ROOT" | \
  while read -r line; do
    file=$(echo "$line" | cut -d: -f1)
    func_line=$(echo "$line" | cut -d: -f2)
    # Count lines until next function
    lines=$(tail -n +$func_line "$file" | grep -n "^def \|^fn " | head -1 | cut -d: -f1)
    [ -n "$lines" ] && [ "$lines" -gt 100 ] && echo "$file:$func_line ($lines lines)"
  done | head -3)

if [ -n "$LONG_FUNCS" ]; then
  echo "  âš ï¸  Functions exceeding 100 lines detected:"
  echo "$LONG_FUNCS" | sed 's/^/      /'
  echo "      â†’ Refactor: Extract Method pattern"
  echo "      â†’ Target: <50 lines per function"
  echo "      â†’ Tool: Automated refactoring in PyCharm/VS Code"
  echo ""
fi

# Code duplication
if command -v jscpd &> /dev/null; then
  DUPLICATION=$(jscpd "$PROJECT_ROOT" --reporters json 2>/dev/null | jq -r '.statistics.total.percentage // "0"')
  if (( $(echo "$DUPLICATION > 5" | bc -l) )); then
    echo "  âš ï¸  Code duplication: ${DUPLICATION}% (target: <5%)"
    echo "      â†’ Tool: jscpd, PMD CPD"
    echo "      â†’ Refactor: Extract common logic to utilities"
    echo "      â†’ Pattern: DRY principle - Don't Repeat Yourself"
    echo ""
  fi
fi

# Cyclomatic complexity
if command -v radon &> /dev/null; then
  COMPLEX=$(radon cc "$PROJECT_ROOT" -a -s | grep -E "C|D|E|F" | head -3)
  if [ -n "$COMPLEX" ]; then
    echo "  âš ï¸  High cyclomatic complexity detected:"
    echo "$COMPLEX" | sed 's/^/      /'
    echo "      â†’ Refactor: Replace nested if/else with guard clauses"
    echo "      â†’ Refactor: Extract complex conditions to named functions"
    echo "      â†’ Target: Complexity <10 per function"
    echo ""
  fi
fi

# Tool Recommendations
echo "ğŸ› ï¸  Recommended Tools:"
echo ""

echo "  Development:"
echo "      â†’ pre-commit: Automated code quality checks"
echo "      â†’ black/ruff: Auto-formatting and linting (Python)"
echo "      â†’ rustfmt/clippy: Formatting and linting (Rust)"
echo "      â†’ husky: Git hooks for commit validation"
echo ""

echo "  Monitoring:"
echo "      â†’ Sentry: Error tracking and performance monitoring"
echo "      â†’ Prometheus + Grafana: Metrics and alerting"
echo "      â†’ OpenTelemetry: Distributed tracing"
echo "      â†’ New Relic / Datadog: APM"
echo ""

echo "  Security:"
echo "      â†’ Bandit: Python security linter"
echo "      â†’ Safety: Dependency vulnerability scanning"
echo "      â†’ Semgrep: SAST (Static Application Security Testing)"
echo "      â†’ Dependabot: Automated dependency updates"
echo ""

# Learning Resources
echo "ğŸ“š Learning Resources:"
echo ""

if echo "$CHUNK_NAME" | grep -iq "api"; then
  echo "  API Design:"
  echo "      â†’ Book: 'REST API Design Rulebook' by Masse"
  echo "      â†’ Doc: https://restfulapi.net/"
  echo "      â†’ Pattern: Richardson Maturity Model"
  echo ""
fi

if echo "$CHUNK_NAME" | grep -iq "test"; then
  echo "  Testing:"
  echo "      â†’ Book: 'Unit Testing Principles' by Khorikov"
  echo "      â†’ Article: Google Testing Blog - testing-on-the-toilet"
  echo "      â†’ Pattern: Arrange-Act-Assert (AAA)"
  echo ""
fi

if echo "$CHUNK_NAME" | grep -iq "performance"; then
  echo "  Performance:"
  echo "      â†’ Book: 'High Performance Python' by Gorelick"
  echo "      â†’ Tool: py-spy (sampling profiler)"
  echo "      â†’ Pattern: Profile first, optimize second"
  echo ""
fi

# Phase-Specific Genius Recommendations
echo ""
echo "ğŸ¯ Phase-Specific Genius Move:"
echo ""

# Contextual brilliance based on phase
if echo "$CHUNK_NAME" | grep -iq "auth"; then
  cat <<EOF
  Instead of rolling your own auth (risky):
  â†’ Use: django-allauth, Flask-Security-Too, or Authlib
  â†’ Add: Social auth (Google, GitHub) for free
  â†’ Implement: Passwordless magic links (better UX)
  â†’ Enable: 2FA with pyotp + qrcode libraries
  â†’ Result: Production-grade auth in 1 day vs 2 weeks

  Genius pattern: Auth0 integration
    Cost: Free tier covers 7,000 users
    Gain: Enterprise-grade security without maintenance
    Code: 30 lines vs 3,000 lines custom implementation
EOF

elif echo "$CHUNK_NAME" | grep -iq "api"; then
  cat <<EOF
  Instead of manual API versioning:
  â†’ Pattern: Header-based versioning (Accept: application/vnd.api.v2+json)
  â†’ Tool: FastAPI automatic OpenAPI generation
  â†’ Add: API rate limiting + circuit breakers
  â†’ Enable: GraphQL alongside REST (best of both)
  â†’ Result: Flexible, self-documenting, scalable API

  Genius move: API Gateway pattern
    Use: Kong, Tyk, or AWS API Gateway
    Gain: Rate limiting, auth, monitoring, caching centralized
    Deploy: Once, benefits every endpoint
EOF

elif echo "$CHUNK_NAME" | grep -iq "database\|model"; then
  cat <<EOF
  Instead of active record pattern:
  â†’ Use: Repository pattern + Query objects
  â†’ Add: Read replicas for scalability
  â†’ Implement: CQRS (Command Query Responsibility Segregation)
  â†’ Enable: Event sourcing for audit trail
  â†’ Result: 10x scalability, easier testing

  Genius optimization: Connection pooling
    Tool: PgBouncer (PostgreSQL), ProxySQL (MySQL)
    Gain: 100 connections â†’ 10,000 concurrent users
    Cost: 5 minute setup, massive performance gain
EOF

elif echo "$CHUNK_NAME" | grep -iq "test"; then
  cat <<EOF
  Instead of traditional unit tests only:
  â†’ Add: Property-based testing (Hypothesis)
  â†’ Add: Contract testing (Pact) for APIs
  â†’ Add: Visual regression testing (Percy, Chromatic)
  â†’ Add: Chaos engineering (toxiproxy)
  â†’ Result: Catch bugs traditional testing misses

  Genius strategy: Testing Trophy (not Pyramid)
    Focus: Integration tests (70%) > Unit (20%) > E2E (10%)
    Benefit: Better ROI, catches real issues
    Tool: pytest-docker for integration test fixtures
EOF

elif echo "$CHUNK_NAME" | grep -iq "deploy\|ci"; then
  cat <<EOF
  Instead of manual deployment:
  â†’ Pattern: GitOps (Flux, ArgoCD)
  â†’ Add: Blue-green deployment for zero downtime
  â†’ Add: Feature flags (LaunchDarkly, Unleash)
  â†’ Add: Canary releases (progressive rollout)
  â†’ Result: Deploy 10x/day safely vs 1x/month nervously

  Genius move: Preview environments
    Tool: Vercel, Netlify, or Kubernetes namespaces
    Gain: Every PR gets isolated environment
    Benefit: Test before merge, show stakeholders
EOF
fi

echo ""
```

## Integration Instructions

Add this section between the current Step 8 (Calculate Score) and Step 9 (Actionable Next Steps).

The genius recommendations will:
1. Detect anti-patterns automatically
2. Suggest specific, proven solutions
3. Recommend tools with justification
4. Provide learning resources
5. Offer phase-specific brilliant moves
6. Calculate concrete benefits (ROI, time saved, performance gains)

Each recommendation includes:
- âš ï¸ Problem identified
- â†’ Specific solution
- ğŸ’¡ Tool/library/pattern name
- âœ¨ Expected benefit/result
